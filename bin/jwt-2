#!/usr/bin/env node
const { SignJWT, CompactSign, jwtVerify, calculateJwkThumbprint, importJWK, exportJWK } = require('jose')
const config = require('../config')

var argv = require('minimist')(process.argv.slice(2))

if (argv.help) {
	console.log(`
usage: jwt [--help] [--sign] [--subject] [--payload] [--verify] [--jwt] [--expires] [--verbose]

Options:
--sign         Sign payload
--subject      Subject of jwt
--payload      Payload to sign
--verify       Verify jwt
--jwt          JWT tp verify
--expires      Expires in
--verbose      Show keys
--help         Show available options	
`)
	process.exit()
}

const sign = (argv.sign && !argv.verify) ? true : (!argv.sign && !argv.verify ? true : false)
const subject = argv.subject || 'Jz9uAKouzDfjEQ5bap1Tgu'
const payload = argv.payload ? JSON.parse(argv.payload) : JSON.parse('{"email": "someone@example.com"}')
const verify = (argv.verify && !argv.sign) ? true : false
const jwt = argv.jwt || 'eyJhbGciOiJSUzI1NiIsImtpZCI6ImRsc290M3NHZ2Nma3ZsdlBtRTVNb242aGVSdy1aN3U1cjhxX1V6Z3otSEkifQ.eyJlbWFpbCI6InNvbWVvbmVAZXhhbXBsZS5jb20iLCJzdWIiOiJKejl1QUtvdXpEZmpFUTViYXAxVGd1IiwiYXVkIjoidXJuOmZvcm1hdGxpYnJhcnk6YXBpIiwiaXNzIjoidXJuOmZvcm1hdGxpYnJhcnk6YXV0aCIsImlhdCI6MTY2MjY4NjM0MywiZXhwIjoxOTc4MjYyMzQzfQ.XJWaSBe1600YYYSh6Otg-gaUVK8aoauO_b_qX85iew7wcuBLoGVF-YpU7ocZT0XhLtexbc03hR-YQnImF1iNPhZXLCunXV4jkDv9CfMyVjL12yDtMqQU95olmVeBS9d8nBuLhLx3tqIv32b0UEGh8s6xKoNLtfRXxo0NJqcbPIxRo24zgy4kaWEd9pA6f-x9Kdn5XAomYfBQXHhlwjLFdSWtNudXpYsg33-RgjfzIh-7S6JwyRgCv0iPotHK0u8LS7IrnivOcYs5VyNXmZJoI67H9Vl0CuH1xsB8bEYU6zDOSOmlWLBnjsapAAP1xTgw3B3QtgpY7rU2qsz3cy5gAw'
const expires = argv.expires || '15m'
const verbose = argv.verbose || false

// const algorithm = 'RS256'
const issuer = 'urn:formatlibrary:auth'
const audience = 'urn:formatlibrary:api'

;(async () => {

	const privateJwks = (config.siteJWKS || [])
	verbose && console.log('jwks (private): ', privateJwks)
    const algorithm = privateJwks[0].alg || 'RS256'

	const keys = await Promise.all(privateJwks.map((privateJwk) => importJWK(privateJwk, algorithm)))
	verbose && console.log('keys (raw): ', keys)

	const publicKeys = await Promise.all(keys.map((key) => exportJWK(key, false)))
	verbose && console.log('jwks (public): ', publicKeys)


	if (sign) {
		console.log('payload: ', payload)
		const privateJwk = privateJwks[0]
		verbose && console.log('jwk (private): ', privateJwk)
		const kid = await calculateJwkThumbprint(privateJwk, 'sha256')
		verbose && console.log('kid: ', kid)
		const key = keys[0]
		verbose && console.log('key (raw): ', key)

		let signed
		try {
			signed = await new SignJWT(payload)
				.setProtectedHeader({ alg: algorithm, kid })
				.setSubject(subject)
				.setAudience(audience)
				.setIssuer(issuer)
				.setIssuedAt()
				.setExpirationTime(expires)
				.sign(key)
		} catch (error) {
			console.error(error)
			throw new Error('Failed to sign JWT!')
		}
		console.log('signed: ', signed)
	}

	if (verify) {
		console.log('jwt: ', jwt)
		const publicKey = publicKeys[0]
		verbose && console.log('jwk (public): ', publicKey)

		const key = await importJWK(publicKey, algorithm)
		verbose && console.log('publicKey (raw): ', key)

		let claims
		try {
			claims = await jwtVerify(jwt, key, {
				issuer,
				audience
			})
		} catch (error) {
			console.error(error)
			throw new Error('Failed to verify JWT!')
		}
		console.log('claims: ', claims && claims.payload)
	}

})()
